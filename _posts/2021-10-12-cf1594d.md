---
title: 'Problem: The Number of Imposters'
tags:
  - graph
  - connected component
---
Cho n người chơi cùng chơi game. mỗi người sẽ là imposter hoặc crewmate. imposter là người luôn nói dối, cewmate là người luôn nói thật. cho m nhận xét có dạng (i, j, c) ví dụ: 1 2 imposter, tức là người chơi 1 nói người chơi 2 là imposter, như vậy nếu người chơi 2 đúng là imposter thì người chơi 1 là crewmate, và ngược lại.
Tính số lượng **tối đa** imposter  trong game.

<!--more-->

**Hướng giải:**

- Quy bài toán về dạng đồ thị 2n đỉnh. với người chơi i tương ứng sẽ có 2 đỉnh i và i + n, đại diện cho 2 trường hợp là crewmate và imposter.
- Như vậy sẽ hình thành đồ thị với các thành phần liên thông. Trong đó nếu tồn tại 1 thành phần liên thông mà có đỉnh i và i + n liên thông với nhau thì suy ra không tồn tại game như vậy, xuất -1.

![image](https://user-images.githubusercontent.com/83690404/136875128-a32a6a71-0191-46ba-b217-53f2fc91b8ad.png)

Trong hình:
- đỉnh 1 - 5 - 6 là 1 thành phần liên thông, có 2 imposter
- đỉnh 2 - 3 là 1 thành phần liên thông, có 0 imposter
- đỉnh 4 là 1 thành phần liên thông, có 1 imposter.

**Code:**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define debug(x) cerr << #x << " = " << x << endl;
#define int long long

main(){
    // freopen("input.txt", "r", stdin);
    ios_base::sync_with_stdio(0);cin.tie(0);
    int t;
    cin >> t;
    while(t--){
        int n, m;
        cin >> n >> m;
        vector<int> adj[2 * n + 1];
        while(m--){
            int x, y;
            string s;
            cin >> x >> y >> s;
            if(s[0] == 'i'){
                adj[x].push_back(y + n);
                adj[y + n].push_back(x);
                adj[x + n].push_back(y);
                adj[y].push_back(x + n);
            }
            else{
                adj[x].push_back(y);
                adj[y].push_back(x);
                adj[x + n].push_back(y + n);
                adj[y + n].push_back(x + n);
            }
        }
        vector<bool> visitted(2 * n + 1, 0);
        int cntImposter = 0;
        bool ok = 0;
        vector<int> temp(2 * n + 1, 0);
        int temp1 = 0;
        int cnt = 0;
        function<void(int)> dfs = [&](int x){
            visitted[x] = 1;
            temp[x] = temp1;
            cnt++;
            if(x > n && temp[x - n] == temp[x]) ok = 1;
            else if(x <= n && temp[x + n] == temp[x]) ok = 1;
            if(x > n) cntImposter++;
            for(auto v: adj[x]){
                if(visitted[v]) continue;
                dfs(v);
            }
        };
        int res = 0;
        for(int i = 1; i <= n; i++){
            if(visitted[i] == 0 && visitted[i + n] == 0){
                temp1++;
                dfs(i);
                if(ok) break;
                else res += max(cnt - cntImposter, cntImposter);
                cntImposter = 0;
                cnt = 0;
            }
        }
        if(ok){
            cout << "-1\n";
            continue;
        }
        cout << res << "\n";
    }
}
```
